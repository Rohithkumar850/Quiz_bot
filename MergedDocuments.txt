Lecture 1Network Security
Introduction
Chapter 1Learning Objective
‚Ä¢Introduce the security requirements 
‚Ä¢confidentiality
‚Ä¢integrity
‚Ä¢availability
‚Ä¢Describe the X. 800 security architecture for OSI Network Security RequirementsNetwork Security
‚Ä¢Definition: The protection afforded to an automated information 
system in order to attain the application objectives to preserving the 
integrity , availability , and confidentiality of information system 
resources (includes hardware, software, firmware, information/data, 
and telecommunications).  
-NIST Computer Security HandbookConfidentiality
‚Ä¢Data confidentiality: Assures that private or confidential information 
is not made available or disclosed to unauthorized individuals; 
‚Ä¢Privacy: Assures that individual's control or influence what 
information related to them may be collected and stored and by 
whom and to whom that information may be disclosed
‚Ä¢i.e., student grade informationIntegrity
‚Ä¢Data integrity: Assures that data (both stored and in transmitted 
packets) and programs are changed only in a specified and authorized
manner;
‚Ä¢System integrity: Assures that a system performs its intended 
function in an unimpaired manner, free from deliberate or 
inadvertent unauthorized manipulation of the system
‚Ä¢i.e., a hospital patient ‚Äôs allergy information  Availability
‚Ä¢Availability: Assures that systems work promptly, and service is not 
denied to authorized users, ensuring timely and reliable access to and 
use of information
‚Ä¢i.e., denial of service attackOther security requirements
‚Ä¢Authenticity
‚Ä¢Accountability
‚Ä¢tracible data source, 
‚Ä¢fault isolation
‚Ä¢intrusion detection and prevention, 
‚Ä¢recovery and legal action
‚Ä¢system must keep records of their activities to permit later forensic analysis to 
trace security breaches or to aid in transaction disputesQuestion
‚Ä¢What security requirements does a blockchain system have achieved? Project 
‚Ä¢Task 1: OnDemand Professor Q&A Bot 
‚Ä¢Your task is to build a Q&A Bot over private data that answers questions about the network security course using the open -
source alternatives to ChatGPT that can be run on your local machine. Data privacy can be compromised when sending 
data over the internet, so it is mandatory to keep it on your local system. 
‚Ä¢Your Q&A Bot should be able to understand user questions and provide appropriate answers from the local database, then 
the citations should be added (must be accomplished) if the response is from the internet, then the web references 
should be added. 
‚Ä¢Train your bot using network security lecture slides, network security textbook, and the Internet. 
‚Ä¢By using Wireshark capture data for Step 4's of the LLM workflow shown in Figure 1. Provide detailed explanations of the trace data. 
Also, Maintain a record of Step 1's prompt and its mapping to the trace data in Step 4's.
‚Ä¢Task 2: Quiz Bot 
‚Ä¢Your task is to build a quiz bot based on a network security course using the open -source alternatives to ChatGPT that can 
be run on your local machine. Data privacy can be compromised when sending data over the internet, so it is mandatory to 
keep it on your local system. 
‚Ä¢Two types of questions should be offered by the bot: randomly generated questions and specific topic questions and the 
answers should be pulled from the network security database. Train your bot using network security quizzes, lecture slides, 
network security textbook, and the Internet. 
‚Ä¢The quiz must include multiple -choice questions, true/false questions, and open -ended questions. 
‚Ä¢Finally, the bot should be able to provide feedback on the user's answers. Form Project Groups
‚Ä¢Form a group (no submission) 
‚Ä¢The project will be assigned as a group project. Six students will be considered 
a group for a project. Here is the link to enter your project group member 
names. 
FALL 2023 CS5342 PROJECT GROUP NAMES.xlsx 
‚Ä¢It is recommended that one person in the group fills in the form to avoid 
multiple entries and submits project files on Blackboard. If you cannot get a 
group, contact to TA. 
‚Ä¢Deadline to submit your group members is 11:59 PM on Sept 8th, 
2023Email communication
‚Ä¢Email subject: course# _course name_reason
‚Ä¢such as ‚ÄúCS 5342 _network security_late submission ‚ÄùLecture 10Stream CiphersStream Ciphers
‚Ä¢process the message bit by bit (as a stream) 
‚Ä¢typically have a (pseudo) random stream key
‚Ä¢combined (XOR) with plaintext bit by bit 
‚Ä¢randomness of stream key completely destroys any statistically 
properties in the message 
‚Ä¢Ci= MiXOR StreamKeyi
‚Ä¢what could be simpler!!!! 
‚Ä¢but must never reuse stream key
‚Ä¢otherwise, can remove effect and recover messages, M ‚®ÅK‚®ÅK = MHow to generate Stream Key?
‚Ä¢How to generate Stream Key?Stream Ciphers 
‚Ä¢Idea: replace ‚Äúrand‚Äù by ‚Äúpseudo rand‚Äù
‚Ä¢Use Pseudo Random Number Generator 
‚Ä¢A secure PRNG produces output that looks indistinguishable from random
‚Ä¢An attacker who can‚Äôt see the internal PRNG state can‚Äôt learn any output
‚Ä¢PRNG: {0,1}sÔÇÆ{0,1}n
‚Ä¢expand a short (e.g., 128 -bit) random seed into a long (typically unbounded) 
string that ‚Äúlooks random‚Äù
‚Ä¢Secret key is the seed
‚Ä¢Basic encryption method: Ekey[M] = M ÔÉÖPRNG(key)Stream Ciphers
‚Ä¢Protocol: Alice and Bob both seed a secure PRNG with their 
symmetric secret key, and then use the output as the key for stream 
key
Alice Bob
Seed(k) Seed(k)
Generate(n) Generate(n)
Plaintext Plaintext Ciphertext ‚äï ‚äïStream Ciphers: Encrypting Multiple Messages
‚Ä¢How do we encrypt multiple messages without key reuses?
Alice Bob
Seed(k) Seed(k)
Generate(n) Generate(n)
Plaintext Plaintext Ciphertext ‚äï ‚äïStream Ciphers: Encrypting Multiple Messages
‚Ä¢Solution: For each message, seed the PRNG with the key and a 
random IV, concatenated(‚Äú|‚Äù). Send the IV with the ciphertext
Alice Bob
Seed(k | IV) Seed(k | IV)
Generate(n) Generate(n)
Plaintext Plaintext Ciphertext ‚äï ‚äïIV IVReal-world example: RC4
‚Ä¢A proprietary cipher designed in 1987 
‚Ä¢Extremely simple but effective!
‚Ä¢Very fast -especially in software
‚Ä¢Easily adapts to any key length, byte -oriented stream cipher 
‚Ä¢Uses that permutation to scramble input info processed a byte at a 
time 
‚Ä¢Widely used (web SSL/TLS, wireless WEP , WPA) RC4 Stream Cipher
K RC4 (K|IV) 011010010111
‚äï
MCkey
(seed)key stream
(pseudo random sequence)
messageciphertextRC4 Key Schedule
‚Ä¢starts with an array S of 
numbers: 0‚Ä¶255
‚Ä¢use key to well and truly 
shuffle
‚Ä¢S forms internal state of 
the cipher
‚Ä¢given a key k of length L 
bytes
Throw away T & K, retain SRC4 Encryption
‚Ä¢encryption continues 
shuffling array values
‚Ä¢sum of shuffled pair 
selects "stream key" 
value
‚Ä¢XOR with next byte of 
message to en/decrypt
RC4
Lecture 11Summary ‚ÄìChapter 2
‚Ä¢Symmetric block cipher
‚Ä¢DES, 3DES
‚Ä¢AES
‚Ä¢Random number
‚Ä¢true random number
‚Ä¢pseudorandom number
‚Ä¢Stream cipher 
‚Ä¢The security of symmetric encryption depends on the secrecy of the 
keyHomework 1 -individual
‚Ä¢For Chapter 1 & 2
‚Ä¢Deadline: Oct. 2 (Monday), 11:59 pm
‚Ä¢We will use the blackboard submission time as your final timestamp
‚Ä¢10% penalty per day for late submissionNetwork Security
Chapter 3
Public -Key Cryptography and Message AuthenticationPublic -Key CryptographyConventional cryptography
‚Ä¢traditional private/secret/single -keycryptography uses one key 
‚Ä¢shared by both sender and receiver 
‚Ä¢if this key is disclosed communications are compromised 
‚Ä¢also is symmetric , parties are equal Pros and cons
‚Ä¢Pros:
‚Ä¢Encryption is fast for large amounts of data
‚Ä¢Provide the same level of security with a shorter encryption key
‚Ä¢By now, it‚Äôs unbreakable to quantum computing
‚Ä¢Cons
‚Ä¢Key distribution assumes a secure channel
‚Ä¢Does not protect sender from receiver forging a message & claiming 
it‚Äôs sent by sender
‚Ä¢It does not scale well for large networks. It requires a separate key for 
each pair of communicating parties, which can result in a large number 
of keys to manage and protect. Public -Key Cryptography
‚Ä¢In public -key schemes, each person has two keys
‚Ä¢Public key : Known to everybody
‚Ä¢Private key : Only known by that person
‚Ä¢Keys come in pairs: every public key corresponds to one private key
‚Ä¢Uses number theory
‚Ä¢Examples: Modular arithmetic, factoring, discrete logarithm problem, 
Elliptic logs over Elliptic Curves
‚Ä¢Contrast with symmetric -key cryptography (uses XORs and bit -shifts)
‚Ä¢Messages are numbers
‚Ä¢Contrast with symmetric -key cryptography (messages are bit strings)Lecture 12Public -key Cryptography
‚Ä¢Benefit:
‚Ä¢Drawback:‚Ä¢Benefit: No longer need to assume that Alice and Bob already share a 
secret
‚Ä¢Drawback: Much slower than symmetric -key cryptography
‚Ä¢Number theory calculations are much slower than XORs and bit -shiftsReading materials
‚Ä¢Encryption: Strengths and Weaknesses of Public -key Cryptography
‚Ä¢Public -key cryptography is a public invention due to Whitfield Diffie & 
Martin Hellman at Stanford Uni in 1976Public -key cryptography
‚Ä¢public -key/two -key/asymmetric cryptography involves the use of 
two keys: 
‚Ä¢a public -key, which may be known by anybody, and can be used to encrypt 
messages , and verify signatures
‚Ä¢a private -key, known only to the recipient, used to decrypt messages , and 
sign (create) signatures
‚Ä¢is asymmetric because
‚Ä¢Not the same key
‚Ä¢those who encrypt messages or verify signatures cannot decrypt messages or 
create signaturesPublic -Key Encryption
‚Ä¢Everybody can encrypt with the public key
‚Ä¢Only the recipient can decrypt with the private key
Public -Key Cryptography -Encryption
Encryption steps
‚Ä¢step1: generate a pair of keys
‚Ä¢step2: keep the private key / secret key (SK) and distribute the public 
key (PK) ‚Äìplace PK in a public register or other accessible file
‚Ä¢step3: Bob encrypts the message with Alice‚Äôs PK
‚Ä¢step4: upon receiving the ciphertext (CT), Alice decrypt CT with SKPublic -Key Encryption: Definition
‚Ä¢Three parts:
‚Ä¢KeyGen () ‚Üí PK, SK: Generate a public/private keypair, where PKis the public 
key, and SKis the private (secret) key
‚Ä¢Enc(PK, M) ‚Üí C: Encrypt a plaintext Musing public key PKto produce 
ciphertext C
‚Ä¢Dec(SK, C) ‚Üí M: Decrypt a ciphertext Cusing secret key SK
‚Ä¢Properties
‚Ä¢Correctness : Decrypting a ciphertext should result in the message that was 
originally encrypted
‚Ä¢Dec(SK, Enc( PK, M)) = Mfor all PK, SK‚Üê KeyGen () and M
‚Ä¢Efficiency : Encryption/decryption should be fast
‚Ä¢Security : 1. Alice (the challenger) just gives Eve (the adversary) the public key, 
and Eve doesn ‚Äôt request encryptions. Eve cannot guess out anything; 2. 
computationally infeasible to recover M with PK and ciphertextPublic -Key Cryptography -Signature
Review
Private Key Public Key
SignatureEncryptionPublic -Key application
‚Ä¢can classify uses into 3 categories:
‚Ä¢encryption/decryption (provide secrecy)
‚Ä¢digital signatures (provide authentication)
‚Ä¢key exchange (of session keys)
‚Ä¢some algorithms are suitable for all uses; others are specific to one
‚Ä¢Either of the two related keys can be used for encryption, with the 
other used for decryption
Security of Public Key Schemes
‚Ä¢Keys used are very large (>512bits) 
‚Ä¢like private key schemes brute force exhaustive search attack is always 
theoretically possible 
‚Ä¢Security relies on a large enough difference in difficulty between easy 
(en/decrypt) and hard (cryptanalyze) problems
‚Ä¢more generally the hard problem is known, it‚Äôs just made too hard to do in 
practice 
‚Ä¢Requires the use of very large numbers , hence is slow compared to 
private/symmetric key schemesPublic -Key Cryptography Algorithm
(RSA)RSA Public -key encryption
‚Ä¢by Rivest, Shamir & Adleman of MIT in 1977 
‚Ä¢currently the ‚Äúwork horse‚Äù of Internet security
‚Ä¢most public key infrastructure (PKI) products
‚Ä¢SSL/TLS: certificates and key -exchange
‚Ä¢secure e -mail: PGP , Outlook, ‚Ä¶.
‚Ä¢based on exponentiation in a finite (Galois) field over integers modulo a 
prime 
‚Ä¢exponentiation takes O((log n)3) operations (easy)
‚Ä¢security due to cost of factoring large integer numbers 
‚Ä¢factorization takes O(e log n log log n) operations (hard)
‚Ä¢uses large integers ( eg.1024 bits)RSA key setup
‚Ä¢each user generates a public/private key pair by: 
‚Ä¢selecting two large primes at random -p, q
‚Ä¢computing their system modulus n=p‚àôq
‚Ä¢note √∏(n)=(p-1)(q-1)
‚Ä¢selecting at random the encryption key e
‚Ä¢where 1<e<√∏(n), gcd(e,√∏(n))=1 
‚Ä¢solve following equation to find decryption key d
‚Ä¢ed=1 mod √∏(n)
‚Ä¢publish their public encryption key: pk={ e,n} 
‚Ä¢keep secret private decryption key: sk={d,p,q } 
RSA example
1. Select primes: p=17 & q=11
2. Computen = pq=17√ó11=187
3. Compute√∏(n)=(p‚Äì1)(q-1)=16√ó10=160
4. Select e: gcd(e,160)=1; choose e=7
5. Determine d: de=1 mod 160 and d < 160 Value is d=23 since 
23√ó7=161= 10 √ó160+1
6. Publish public key pk={7,187}
7. Keep secret private key sk={23,17,11}
RSA use
‚Ä¢to encrypt a message M the sender:
‚Ä¢obtains public key of recipient pk={e,n}
‚Ä¢computes: C=Memod n , where 0‚â§M<n
‚Ä¢to decrypt the ciphertext C the owner:
‚Ä¢uses their private key sk={d,p,q}
‚Ä¢computes: M=Cdmod n
‚Ä¢note that the message M must be smaller than the modulus n (block 
if needed)
Plaintext CiphertextC = ùëÄùëí
pk={e,n} sk={d,p,q}Lecture 14RSA use
‚Ä¢to encrypt a message M the sender:
‚Ä¢obtains public key of recipient pk={e,n}
‚Ä¢computes: C=Memod n , where 0‚â§M<n
‚Ä¢to decrypt the ciphertext C the owner:
‚Ä¢uses their private key sk={d,p,q}
‚Ä¢computes: M=Cdmod n
‚Ä¢note that the message M must be smaller than the modulus n (block 
if needed)
Plaintext CiphertextC = ùëÄùëí
pk={e,n} sk={d,p,q}RSA example continue
‚Ä¢sample RSA encryption/decryption is: 
‚Ä¢given message M = 88 ( 88<187 )
‚Ä¢encryption:
C = 887mod 187 = 11
‚Ä¢decryption:
M = 1123mod 187 = 88Example of RSA algorithm
RSA key generation
‚Ä¢users of RSA must:
‚Ä¢determine two primes at random -p, q
‚Ä¢select either eor dand compute the other
‚Ä¢primes p,q must not be easily derived from modulus n=p.q
‚Ä¢means must be sufficiently large
‚Ä¢typically guess and use probabilistic test
‚Ä¢exponents e, dare inverses, so use Inverse algorithm to compute the 
otherCorrectness of RSA
‚Ä¢Euler‚Äôs theorem: if gcd(M, n) = 1, then ùëÄùúô(ùëõ)=1mod n. Here œÜ(n) 
is Euler‚Äôs totient function: the number of integers in {1, 2, . . ., n-1} 
which are relatively prime to n. When nis a prime, this theorem is 
just Fermat‚Äôs little theorem
M‚Äô = ùê∂ùëëmod n=ùëÄùëíùëëmod n
=ùëÄùëòùúôùëõ+1mod n
=[ùëÄùúô(ùëõ)]ùëò‚àôùëÄmodn
= M  mod nAttack approaches
‚Ä¢Mathematical attacks : several approaches, all equivalent in effort to 
factoring the product of two primes. The defense against 
mathematical attacks is to use a large key size. 
‚Ä¢Timing attacks : These depend on the running time of the decryption 
algorithm
‚Ä¢Chosen ciphertext attacks : this type of attacks exploits properties of 
the RSA algorithm by selecting blocks of data. These attacks can be 
thwarted by suitable padding of the plaintext, such as PKCS1 V1.5 in 
SSLHomomorphic encryption 
‚Ä¢Encryption scheme that allows computation on ciphertexts 
‚Ä¢i.e. a public -key encryption scheme that allows anyone in possession of the 
public key to perform operations on encrypted data without access to the 
decryption key
‚Ä¢Initial public -key systems that allow this for either addition or 
multiplication, but not both.
‚Ä¢Fully homomorphic encryption (FHE)Application of homomorphic encryption 
‚Ä¢One Use case: cloud computing 
‚Ä¢A weak computational device Alice (e.g., a mobile phone or a laptop) wishes 
to perform a computationally heavy task, beyond her computational means. 
She can delegate it to a much stronger (but still feasible) machine Bob (the 
cloud, or a supercomputer) who offers the service of doing so. The problem is 
that Alice does not trust Bob, who may give the wrong answer due to laziness, 
fault, or malice.
E (Pk, data)
E (Pk, f(data))RSA reading materials
‚Ä¢A Method for Obtaining Digital Signatures and Public -Key 
CryptosystemsLecture 15Message AuthenticationMessage authentication
‚Ä¢message authentication is concerned with: 
‚Ä¢protecting the integrity of a message 
‚Ä¢validating identity of originator 
‚Ä¢non-repudiation of origin (dispute resolution)
‚Ä¢then three alternative functions used:
‚Ä¢message encryption -symmetric
‚Ä¢message authentication code (MAC)
‚Ä¢digital signature
Message encryption
‚Ä¢Symmetric message encryption by itself also provides a measure of 
authentication
‚Ä¢if symmetric encryption is used then:
‚Ä¢receiver knows sender must have created it
‚Ä¢since only sender and receiver know key used
‚Ä¢know content cannot be alteredHomework 1 questions
‚Ä¢Q1: Symmetric Block Cypher provides authentication and 
confidentiality
‚Ä¢Ans: TrueMessage encryption
‚Ä¢if public -key encryption is used:
‚Ä¢encryption provides no confidence of sender
‚Ä¢since anyone potentially knows public -key
‚Ä¢so, need to recognize corrupted messages
‚Ä¢however, if 
‚Ä¢sender signs message using their private -key
‚Ä¢then encrypts with recipients‚Äô public key
‚Ä¢have both secrecy and authentication
‚Ä¢but at cost of two public -key uses on messageReasons to avoid encryption authentication
‚Ä¢Encryption software is quite slow
‚Ä¢Encryption hardware costs are nonnegligible
‚Ä¢Encryption hardware is optimized toward large data sizes
‚Ä¢An encryption algorithm may be protected by a patentHash FunctionHash functions
‚Ä¢Hash function: h = H(M)
‚Ä¢M can be of any size 
‚Ä¢h is always of fixed size 
‚Ä¢Typically, h << size(M) One use case -using hash function
‚Ä¢Initialization: A and B share a 
common secret, SAB
‚Ä¢Message, M
‚Ä¢A calculates MDM= H (SAB|| M)
‚Ä¢B recalculates MD‚ÄôM, and check
‚Ä¢MD‚ÄôM= MDM
This scheme cannot provide authentication. Lecture 16Hash FunctionHash functions
‚Ä¢Hash function: h = H(M)
‚Ä¢M can be of any size 
‚Ä¢h is always of fixed size 
‚Ä¢Typically, h << size(M) One use case -using hash function
‚Ä¢Initialization: A and B share a 
common secret, SAB
‚Ä¢Message, M
‚Ä¢A calculates MDM= H (SAB|| M)
‚Ä¢B recalculates MD ‚ÄôM, and check
‚Ä¢MD‚ÄôM= MDM
This scheme cannot provide authentication. Requirements for secure hash functions
‚Ä¢1. can be applied to any sized message M
‚Ä¢2. produces fixed -length output h
‚Ä¢3. is easy to compute h=H(M) for any message M
‚Ä¢4. given his infeasible to find xs.t.H(x)=h
‚Ä¢one-way property or preimage resistance
‚Ä¢5. given xis infeasible to find x‚Äôs.t.H(x‚Äô)=H(x)
‚Ä¢weak collision resistance or second pre -image resistant
‚Ä¢6. infeasible to find any pair of x,x‚Äôs.t.H(x‚Äô)=H(x)
‚Ä¢strong collision resistanceHash Function: Collision Resistance
‚Ä¢Collision : Two different inputs with the same output
‚Ä¢x‚â† x' and H(x) = H(x')
‚Ä¢Can we design a hash function with no collisions?
‚Ä¢No, because there are more inputs than outputs (pigeonhole principle)
‚Ä¢However, we want to make finding collisions infeasible for an attacker
‚Ä¢Collision resistance : It is infeasible to (i.e. no polynomial time attacker 
can) find any pair of inputs x'‚â† xsuch that H(x) = H(x')Secure hash function
‚Ä¢A hash function that satisfies the first five properties is referred to as 
a weak hash function
‚Ä¢Security: random/unpredictability, no predictable patterns for how 
changing the input affects the output
‚Ä¢Changing 1 bit in the input causes the output to be completely different
‚Ä¢Also called ‚Äúrandom oracle‚Äù assumption
‚Ä¢A message digest
‚Ä¢a fixed size numeric representation of the contents of a message, computed 
by a hash function
‚Ä¢Examples: SHA -1 (Secure Hash Algorithm 1), SHA -2, SHA -3, MD5Hash Function: Examples
‚Ä¢MD5
‚Ä¢Output: 128 bits
‚Ä¢Security: Completely broken
‚Ä¢SHA-1
‚Ä¢Output: 160 bits
‚Ä¢Security: Completely broken in 2017
‚Ä¢Was known to be weak before 2017 , but still used sometimes
‚Ä¢SHA-2
‚Ä¢Output: 256, 384, or 512 bits (sometimes labeled SHA -256, SHA -384, SHA -512)
‚Ä¢Not currently broken, but some variants are vulnerable to a length extension attack
‚Ä¢Current standard
‚Ä¢SHA-3 (Keccak)
‚Ä¢Output: 256, 384, or 512 bits
‚Ä¢Current standard (not meant to replace SHA -2, just a different construction)Length Extension Attacks
‚Ä¢Length extension attack : Given H(x) and the length of x, but not x, an 
attacker can create H(x || m) for any mof the attacker ‚Äôs choosing
‚Ä¢Length extension attack -Wikipedia
‚Ä¢SHA-256 (256-bit version of SHA -2) is vulnerable
‚Ä¢SHA-3 is not vulnerableLecture 17Length Extension Attacks
‚Ä¢Length extension attack : Given H(x) and the length of x, but not x, an 
attacker can create H(x || m) for any mof the attacker ‚Äôs choosing
‚Ä¢Length extension attack -Wikipedia
‚Ä¢SHA-256 (256-bit version of SHA -2) is vulnerable
‚Ä¢SHA-3 is not vulnerableDoes hashes provide integrity?
‚Ä¢It depends on your threat model
‚Ä¢Scenario
‚Ä¢Mozilla publishes a new version of Firefox on some download servers
‚Ä¢Alice downloads the program binary
‚Ä¢How can she be sure that nobody tampered with the program?
‚Ä¢Idea: use cryptographic hashes
‚Ä¢Mozilla hashes the program binary and publishes the hash on its website
‚Ä¢Alice hashes the binary she downloaded and checks that it matches the hash on the website
‚Ä¢If Alice downloaded a malicious program, the hash would not match (tampering detected!)
‚Ä¢An attacker can‚Äôt create a malicious program with the same hash (collision resistance)
‚Ä¢Threat model: We assume the attacker cannot modify the hash on the website
‚Ä¢We have integrity, as long as we can communicate the hash securelyDo hashes provide integrity?
‚Ä¢It depends on your threat model
‚Ä¢Scenario
‚Ä¢Alice and Bob want to communicate over an insecure channel
‚Ä¢David might tamper with messages
‚Ä¢Idea: Use cryptographic hashes
‚Ä¢Alice sends her message with a cryptographic hash over the channel
‚Ä¢Bob receives the message and computes a hash on the message
‚Ä¢Bob checks that the hash he computed matches the hash sent by Alice
‚Ä¢Threat model: David can modify the message and the hash
‚Ä¢No integrity!Man -in-the-middle attack
AliceM‚Äô
MD‚ÄôM
MDM
MDM‚Äô
MD‚Äô
Bob DavidDo hashes provide integrity? 
‚Ä¢It depends on your threat model
‚Ä¢If the attacker can modify the hash, hashes don‚Äôt provide integrity
‚Ä¢Main issue: Hashes are unkeyed functions
‚Ä¢There is no secret key being used as input, so any attacker can compute a 
hash on any valueSolutions
‚Ä¢A message digest created using a secret symmetric key is known as a 
Message Authentication Code (MAC), because it can provide 
assurance that the message has not been modified
‚Ä¢The sender can also generate a message digest and then encrypt the 
digest using the private key of an asymmetric key pair, forming a 
digital signature . The signature must then be verified by the receiver 
through comparing it with a locally generated digestHashes: Summary
‚Ä¢Map arbitrary -length input to fixed -length output
‚Ä¢Output is deterministic
‚Ä¢Security properties
‚Ä¢One way: Given an output y, it is infeasible to find any input xsuch that H(x) = y.
‚Ä¢Second preimage resistant: Given an input x, it is infeasible to find another input x'‚â† 
xsuch that H(x) = H(x').
‚Ä¢Collision resistant: It is infeasible to find another any pair of inputs x'‚â† xsuch that 
H(x) = H(x').
‚Ä¢Some hashes are vulnerable to length extension attacks
‚Ä¢Hashes don ‚Äôt provide integrity (unless you can publish the hash securely)Lecture 18Message Authentication CodeMessage authentication code (MAC)
‚Ä¢generated by an algorithm that creates a small fixed -sized block
‚Ä¢depending on both message and some key
‚Ä¢not be reversible
‚Ä¢MACM= F(KAB, M)
‚Ä¢appended to message as a signature
‚Ä¢receiver performs same computation on message and checks it 
matches the MAC
‚Ä¢provides assurance that message is unaltered and comes from senderMACs: Usage
‚Ä¢Alice wants to send Mto Bob, but doesn‚Äôt want David to tamper with it
‚Ä¢Alice sends Mand T= MAC( K, M) to Bob
‚Ä¢Bob receives Mand T
‚Ä¢Bob computes MAC( K, M) and checks that it matches T
‚Ä¢If the MACs match, Bob is confident the message has not been 
tampered with (integrity)
MACs: Definition
‚Ä¢Two parts:
‚Ä¢KeyGen () ‚Üí K: Generate a key K
‚Ä¢MAC( K, M) ‚Üí T: Generate a tag Tfor the message Musing key K
‚Ä¢Inputs: A secret key and an arbitrary -length message
‚Ä¢Output: A fixed -length tagon the message
‚Ä¢Properties
‚Ä¢Correctness : Determinism
‚Ä¢Note: Some more complicated MAC schemes have an additional Verify( K, M, T) function 
that don ‚Äôt require determinism, but this is out of scope
‚Ä¢Efficiency : Computing a MAC should be efficient
‚Ä¢Security : existentially unforgeable under chosen plaintext attackExistentially unforgeable
‚Ä¢A secure MAC is existentially unforgeable : without the key, an 
attacker cannot create a valid tag on a message
‚Ä¢David cannot generate MAC( K, M') without K
‚Ä¢David cannot find any M' ‚â† Msuch that MAC( K, M') = MAC( K, M)Example: HMAC
‚Ä¢issued as RFC 2104 [1]
‚Ä¢has been chosen as the mandatory -to-implement MAC for IP Security
‚Ä¢Used in Transport Layer Security (TLS) and Secure Electronic 
Transaction (SET)
[1] ‚ÄúHMAC: Keyed -Hashing for Message Authentication ‚Äù, RFC 2104 , https:// datatracker.ietf.org /doc/html/rfc 2104HMAC(K, M)
‚Ä¢will produce two keys to increase security
‚Ä¢If key is longer than the desired size, we can hash it first, but be 
careful with using keys that are too much smaller, they have to have 
enough randomness in them
‚Ä¢Output H[(K+‚äïopad ) || H[(K+‚äïipad ) || M]]Example: HMAC
‚Ä¢HMAC( K, M):
‚Ä¢Output H[(K+‚äïopad ) || H[(K+‚äïipad ) || M]]
‚Ä¢Use Kto derive two different keys
‚Ä¢opad (outer pad) is the hard -coded byte 0x5crepeated until it ‚Äôs the same 
length as K+
‚Ä¢ipad (inner pad) is the hard -coded byte 0x36repeated until it ‚Äôs the same 
length as K+
‚Ä¢As long as opad and ipad are different, you ‚Äôll get two different keys
‚Ä¢For paranoia, the designers chose two very different bit patterns, even though 
they theoretically need only differ in one bitHMAC 
A B A ‚®ÅB
0 0 0
0 1 1
1 0 1
1 1 0
K+=·âäHùêæùêæùëñùë†ùëôùëéùëüùëîùëíùëüùë°‚Ñéùëéùëõùëèùëôùëúùëêùëòùë†ùëñùëßùëí
ùêæ ùëúùë°‚Ñéùëíùëüùë§ùëñùë†ùëí
ipad = 00110110 , repeat b/8 times
opad = 01011100, repeat b/8 times
HMAC procedure
‚Ä¢Step 1: Append zeros to the left end of K to create a b-bit string K+(e.g., if K 
is of length 160 bits and b = 512, then K will be appended with 44 zero 
bytes); 
‚Ä¢Step 2: XOR (bitwise exclusive -OR) K+ with ipad to produce the b-bit block 
Si;
‚Ä¢Step 3: Append M to Si;
‚Ä¢Step 4: Apply H to the stream generated in step 3; 
‚Ä¢Step 5: XOR K+with opad to produce the b-bit block So;
‚Ä¢Step 6: Append the hash result from step 4 to So;
‚Ä¢Step 7: Apply H to the stream generated in step 6 and output the result. 
Mid-term Exam
‚Ä¢Nov. 3, 2023 ( Friday), 4:00 pm ‚Äì4:50 pm, in class
‚Ä¢Closed book
‚Ä¢Chapter 1 ‚Äì3
‚Ä¢Will have a review classLecture 19Outline
‚Ä¢Review of MAC authentication
‚Ä¢Authenticated encryptionHMAC Properties
‚Ä¢HMAC( K, M) = H[(K+‚äïopad ) || H((K+‚äïipad ) || M]]
‚Ä¢HMAC is a hash function, so it has the properties of the underlying 
hash too
‚Ä¢It is collision resistant
‚Ä¢Given HMAC( K, M), an attacker can ‚Äôt learn M ‚Äìone way
‚Ä¢If the underlying hash is secure, HMAC doesn ‚Äôt reveal M, but it is still 
deterministic
‚Ä¢You can‚Äôt verify a tag Tif you don ‚Äôt have K
‚Ä¢This means that an attacker can ‚Äôt brute -force the message Mwithout 
knowing KMACs: Summary
‚Ä¢Inputs: a secret key and a message
‚Ä¢Output: a tag on the message
‚Ä¢A secure MAC is unforgeable: Even if David can trick Alice into 
creating MACs for messages that David chooses, David cannot create 
a valid MAC on a message that she hasn't seen before
‚Ä¢Example: HMAC( K, M) = H((K+‚äïopad ) || H((K+‚äïipad ) || M))
‚Ä¢MACs do not provide confidentialityDo MACs provide integrity? 
‚Ä¢Do MACs provide integrity?
‚Ä¢Yes. An attacker cannot tamper with the message without being detected
‚Ä¢Do MACs provide authenticity?
‚Ä¢It depends on your threat model
‚Ä¢If only two people have the secret key, MACs provide authenticity: it has a 
valid MAC, and it ‚Äôs not from me, so it must be from the other person
‚Ä¢More than one secret key, If a message has a valid MAC, you can be sure it 
came from someone with the secret key , but you can ‚Äôt narrow it down to one 
person
‚Ä¢Do MACs provide confidentiality?Authenticated EncryptionAuthenticated Encryption: Definition
‚Ä¢Authenticated encryption (AE): A scheme that simultaneously 
guarantees confidentiality and integrity (and authenticity, depending 
on your threat model) on a message
‚Ä¢Two ways of achieving authenticated encryption:
‚Ä¢Combine schemes that provide confidentiality with schemes that provide 
integrity
‚Ä¢Use a scheme that is designed to provide confidentiality and integrityScratchpad: Let ‚Äôs design it together
‚Ä¢You can use:
‚Ä¢An encryption scheme (e.g. AES -CBC): Enc( K, M) and Dec( K, M)
‚Ä¢An unforgeable MAC scheme (e.g. HMAC): MAC( K, M)
‚Ä¢First attempt: Alice sends Enc( K1, M) and MAC( K2, M)
‚Ä¢Integrity? Yes, attacker can ‚Äôt tamper with the MAC
‚Ä¢Confidentiality? No, the MAC is not secure
‚Ä¢Idea 1: Let‚Äôs compute the MAC on the ciphertext instead of the plaintext:
Enc( K1, M)and MAC(k 2, Enc( K1, M))
‚Ä¢Integrity? Yes, attacker can ‚Äôt tamper with the MAC
‚Ä¢Confidentiality? Yes, the MAC might leak info about the ciphertext, but that ‚Äôs okay
‚Ä¢Idea 2: Let‚Äôs encrypt the MAC too: Enc( K1, M|| MAC( K2, M))
‚Ä¢Integrity? Yes, attacker can ‚Äôt tamper with the MAC
‚Ä¢Confidentiality? Yes, everything is encryptedMAC -then -Encrypt or Encrypt -then -MAC?
‚Ä¢Method 1: Encrypt -then -MAC
‚Ä¢First compute Enc( K1, M)
‚Ä¢Then MAC the ciphertext: MAC( K2, Enc( K1, M))
‚Ä¢Method 2: MAC -then -encrypt
‚Ä¢First compute MAC( K2, M)
‚Ä¢Then encrypt the message and the MAC together: Enc(k 1, M||MAC( K2, M))
‚Ä¢Which is better?
‚Ä¢In theory, both are secure if applied properly
‚Ä¢MAC -then -encrypt has a flaw: You don ‚Äôt know if tampering has occurred until after 
decrypting
‚Ä¢Attacker can supply arbitrary tampered input, and you always have to decrypt it
‚Ä¢Passing attacker -chosen input through the decryption function can cause side -channel leaks
‚Ä¢Always use encrypt -then -MAC because it ‚Äôs more robust to mistakesTLS 1.0 ‚ÄúLucky 13‚Äù Attack
‚Ä¢TLS: A protocol for sending encrypted and authenticated messages over the 
Internet
‚Ä¢TLS 1.0 uses MAC -then -encrypt: Enc(k 1, M || MAC(k 2, M))
‚Ä¢The encryption algorithm is AES -CBC
‚Ä¢The Lucky 13 attack abuses MAC -then -encrypt to read encrypted messages
‚Ä¢Guess a byte of plaintext and change the ciphertext accordingly
‚Ä¢The MAC will error, but the time it takes to error is different depending on if the 
guess is correct
‚Ä¢Attacker measures how long it takes to error in order to learn information about 
plaintext
‚Ä¢TLS will send the message again if the MAC errors, so the attacker can guess 
repeatedly
‚Ä¢Takeaways
‚Ä¢Side channel attack: The algorithm is proved secure, but poor implementation made 
it vulnerable
‚Ä¢Always encrypt -then -MAC
‚Ä¢https:// medium.com /@c 0D3M/lucky -13-attack -explained -dd9a9fd42fa6Lecture 2Outline
‚Ä¢Review
‚Ä¢OSI Security Architecture
‚Ä¢Attack model Review
‚Ä¢Security requirements 
‚Ä¢Integrity
‚Ä¢Availability
‚Ä¢Confidentiality
‚Ä¢Authenticity
‚Ä¢AccountabilityChallenges to achieve a secure system
‚Ä¢The mechanisms used to meet those requirements can be quite 
complex , and understanding them may evolve rather subtle reasoning
‚Ä¢When developing security mechanisms, must always consider 
potential attacks
‚Ä¢Sometimes, security mechanisms are counterintuitive
‚Ä¢Where to use them?
‚Ä¢Involve more than a particular algorithm or protocol
‚Ä¢No agreement on security for complex and heterogeneous systems 
i.e. trusts on data in different countries
‚Ä¢etc. OSI Security ArchitectureOSI Security Architecture
‚Ä¢International Telecommunication Union ‚ÄìTelecommunication (ITU -T) 
recommends X.800
‚Ä¢Security Architecture for Open Systems Interconnection (OSI)
‚Ä¢Defines a systematic way of defining and providing security requirements
‚Ä¢Used by IT managers and vendors in their products
Security attacks
Security mechanisms
Security servicesa process (or a device incorporating such a process) 
to detect, prevent, or recover from an attack
enhances the security of the data processing 
systems and the information transfers, such as 
policiesOther Security Architectures
‚Ä¢OWASP -Open Web Application Security Project
‚Ä¢web application security
‚Ä¢OWASP foundation
‚Ä¢NIST, Cybersecurity Framework
‚Ä¢https://www.nist.gov/cyberframework
‚Ä¢VIRTUAL WORKSHOP #2 | February 15, 2023 (9:00 AM ‚Äì5:30 PM EST). Join us 
to discuss potential significant updates to the CSF as outlined in the soon -to-
be-released CSF Concept Paper.
‚Ä¢https://www.nist.gov/news -events/events/2023/02/journey -nist-
cybersecurity -framework -csf-20-workshop -2Security attack
‚Ä¢Definition : any action that compromises the security of information 
owned by an organization
‚Ä¢Two types of security attacks
‚Ä¢Passive attack
‚Ä¢Active attack
Passive attack
‚Ä¢i.e. eavesdropping on or monitoring of transmissions
‚Ä¢Goal: obtain information being transmitted
‚Ä¢release of message contents
‚Ä¢traffic analysis ‚Äìa promiscuous sniffer
‚Ä¢Very difficult to detect ‚Äìno alteration of the data
‚Ä¢But easy to prevent, why?Active attack
‚Ä¢active attack includes:
‚Ä¢replay
‚Ä¢Modification of messages
‚Ä¢Denial of service
‚Ä¢MasqueradeExample: two points communication 
‚Ä¢Generic types of attacks
Example of modification attack in 6LoWPAN
Example: a group of attackers
Know Your Threat Model
‚Ä¢Threat model: A model of who your attacker is and what resources 
they have
‚Ä¢One of the best ways to counter an attacker is to attack their reasonsExample: adversary model
‚Ä¢‚ÄúThe adversary is assumed to be intelligent and has 
limited number of resources. Before capturing the 
nodes, it exploits the various vulnerabilities of the 
networks. It knows the topology of the network, 
routing information. It aims to capture the sink node so 
as to disrupt the whole traffic. If it is not able to 
capture the sink node, it will capture the nearby nodes 
of the sink. It tries to disrupt the whole traffic of the 
network with minimum number of captured nodes. It is 
also assumed that the adversary tends to attack more 
on the nodes closer to the data sink than nodes that 
are far away‚Äù Lecture 20MAC -then -Encrypt or Encrypt -then -MAC?
‚Ä¢Method 1: Encrypt -then -MAC
‚Ä¢First compute Enc(K1, M)
‚Ä¢Then MAC the ciphertext: MAC( K2, Enc(K1, M))
‚Ä¢Method 2: MAC -then -encrypt
‚Ä¢First compute MAC( K2, M)
‚Ä¢Then encrypt the message and the MAC together: Enc(k 1, M||MAC( K2, M))
‚Ä¢Which is better?
‚Ä¢In theory, both are secure if applied properly
‚Ä¢MAC -then -encrypt has a flaw: You don‚Äôt know if tampering has occurred until after 
decrypting
‚Ä¢Attacker can supply arbitrary tampered input, and you always have to decrypt it
‚Ä¢Passing attacker -chosen input through the decryption function can cause side -channel leaks
‚Ä¢Always use encrypt -then -MAC because it‚Äôs more robust to mistakesTLS 1.0 ‚ÄúLucky 13‚Äù Attack
‚Ä¢TLS: A protocol for sending encrypted and authenticated messages over the 
Internet
‚Ä¢TLS 1.0 uses MAC -then -encrypt: Enc(k 1, M || MAC(k 2, M))
‚Ä¢The encryption algorithm is AES -CBC
‚Ä¢The Lucky 13 attack abuses MAC -then -encrypt to read encrypted messages
‚Ä¢Guess a byte of plaintext and change the ciphertext accordingly
‚Ä¢The MAC will error, but the time it takes to error is different depending on if the 
guess is correct
‚Ä¢Attacker measures how long it takes to error in order to learn information about 
plaintext
‚Ä¢TLS will send the message again if the MAC errors, so the attacker can guess 
repeatedly
‚Ä¢Takeaways
‚Ä¢Side channel attack: The algorithm is proved secure, but poor implementation made 
it vulnerable
‚Ä¢Always encrypt -then -MAC
‚Ä¢https:// medium.com /@c0D3M/lucky -13-attack -explained -dd9a9fd42fa6Authenticated Encryption: Summary
‚Ä¢Authenticated encryption: A scheme that simultaneously guarantees 
confidentiality and integrity (and authenticity) on a message
‚Ä¢First approach: Combine schemes that provide confidentiality with 
schemes that provide integrity and authenticity
‚Ä¢MAC -then -encrypt: Enc(K1, M|| MAC( K2, M))
‚Ä¢Encrypt -then -MAC: MAC( K2, Enc(K1, M))
‚Ä¢Always use Encrypt -then -MAC because it's more robust to mistakesDigital SignatureDigital Signatures
‚Ä¢NIST FIPS PUB 186 -4 -the result of a cryptographic transformation of 
data that, when properly implemented, provides a mechanism for 
verifying origin authentication , data integrity , and signatory non-
repudiation
‚Ä¢Based on asymmetric keysDigital Signatures
‚Ä¢Asymmetric cryptography is good because we don‚Äôt need to share a 
secret key
‚Ä¢Digital signatures are the asymmetric way of providing 
integrity/authenticity to data
‚Ä¢Assume that Alice and Bob can communicate public keys without 
David interferingDigital Signatures: Definition
‚Ä¢Three parts:
‚Ä¢KeyGen () ‚Üí PK, SK: Generate a public/private keypair, where PKis the verify (public) key, and SK
is the signing (secret) key
‚Ä¢Sign( SK, M) ‚Üí sig: Sign the message Musing the signing key SKto produce the signature sig
‚Ä¢Verify( PK, M, sig) ‚Üí {0, 1}: Verify the signature sigon message Musing the verify key PKand 
output 1 if valid and 0 if invalid
‚Ä¢Properties:
‚Ä¢Correctness : Verification should be successful for a signature generated over any message
‚Ä¢Verify( PK, M, Sign( SK, M)) = 1 for all PK, SK‚Üê KeyGen () and M
‚Ä¢Efficiency : Signing/verifying should be fast
‚Ä¢Security : Same as for MACs except that the attacker also receives PK
‚Ä¢Namely, no attacker can forge a signature for a messageLecture 21RSA Signature
‚Ä¢KeyGen ():
‚Ä¢Randomly pick two large primes, pand q
‚Ä¢Compute n= pq
‚Ä¢nis usually between 2048 bits and 4096 bits long
‚Ä¢Choose e
‚Ä¢Requirement: eis relatively prime to ( p-1)(q-1)
‚Ä¢Requirement: 2 < e< (p-1)(q-1)
‚Ä¢Compute d= e-1mod ( p-1)(q-1)
‚Ä¢Public key : nand e
‚Ä¢Private key: dRSA Digital Signature Algo
Step 1: Generate a hash value, or message digest, 
mHash from the message M to be signed 
Step 2: Pad mHash with a constant value padding 1 and 
pseudorandom value salt to form M‚Äô 
Step 3: Generate hash value H from M‚Äô
Step 4: Generate a block DB consisting of a constant 
value padding 2 and salt
Step 5: Use the mask generating function MGF, which 
produces a randomized out -put from input H of the 
same length as DB
Step 6: Create the encoded message (EM) block by 
padding H with the hexadecimal constant bcand the 
XOR of DB and output of MGF
Step 7: Encrypt EM with RSA using the signer ‚Äôs private 
key 
RSA Signatures
‚Ä¢Sign( d, M):
‚Ä¢Compute H(M)dmod n
‚Ä¢Verify( e, n, M, sig)
‚Ä¢Verify that H(M) ‚â° sigemod n
RSA Signatures: Correctness
Theorem: sige‚â° H(M)mod N
Proof:
sige= [ùêªùëÄùëë]ùëíùëöùëúùëëùëÅ=ùêª(ùëÄ)ùëíùëëmod N
=ùêª(ùëÄ)ùëòùúôùëõ+1mod N
=[ùêª(ùëÄ)ùúô(ùëõ)]ùëò‚àôùêªùëÄmodN
= H(M)    mod NRSA Digital Signature: Security
‚Ä¢Necessary hardness assumptions:
‚Ä¢Factoring hardness assumption: Given nlarge, it is hard to find primes pq= n
‚Ä¢Discrete logarithm hardness assumption: Given nlarge, hash , and hashdmod 
n, it is hard to find d
‚Ä¢Salt also adds security
‚Ä¢Even the same message and private key will get different signaturesHybrid Encryption
‚Ä¢Issues with public -key encryption
‚Ä¢Notice: We can only encrypt small messages because of the modulo operator
‚Ä¢Notice: There is a lot of math, and computers are slow at math
‚Ä¢Result: We don ‚Äôt use asymmetric for large messages
‚Ä¢Hybrid encryption : Encrypt data under a randomly generated key K
using symmetric encryption, and encrypt Kusing asymmetric 
encryption
‚Ä¢EncAsym(PK, K); EncSym(K, large message)
‚Ä¢Benefit: Now we can encrypt large amounts of data quickly using symmetric 
encryption, and we still have the security of asymmetric encryptionHomework ‚Äìno submission
‚Ä¢RQ: 3.1, 3.2, 3.3, 3.4, 3.6, 3.7
‚Ä¢Problems: 
‚Ä¢prove correctness of RSA digital signature
‚Ä¢3.14Homework 2 -individual
‚Ä¢For Chapter 3
‚Ä¢Deadline: Oct. 26 (Thursday), 11:59 pm
‚Ä¢We will use the blackboard submission time as your final timestamp
‚Ä¢10% penalty per day for late submissionThank you!Lecture 22Network Security
Chapter 4Key DistributionSymmetric Key Distribution and User Authentication
4.2 Ways to achieve symmetric key distribution
‚Ä¢A key could be selected by A and physically delivered to B
‚Ä¢A third party could select the key and physically deliver it to A and B 
‚Ä¢If A and B have previously and recently used a key, one party could 
transmit the new key to the other, using the old key to encrypt the 
new key 
‚Ä¢If A and B each have an encrypted connection to a third -party C, C 
could deliver a key on the encrypted links to A and B Terminologies
‚Ä¢Session key
‚Ä¢Permanent key
‚Ä¢key distribution center (KDC) 
‚Ä¢third party authority, centralized infrastructure
‚Ä¢give permissions for two parties to communicateKerberos
4.3Many -to Many Authentication
How do users prove their identities when requesting services from 
machines on the network?
Threats
‚Ä¢User impersonation
‚Ä¢Malicious user with access to a workstation pretends to be another user from 
the same workstation
‚Ä¢Network address impersonation
‚Ä¢Malicious user changes network address of his workstation to impersonate 
another workstation 
‚Ä¢Eavesdropping, tampering, replay 
‚Ä¢Malicious user eavesdrops, tampers, or replays other users‚Äô conversations to 
gain unauthorized access  Requirements
‚Ä¢Security
‚Ä¢against attacks by eavesdroppers and malicious users
‚Ä¢Transparency
‚Ä¢users shouldn‚Äôt notice authentication taking place
‚Ä¢entering password is ok, if done rarely
‚Ä¢Scalability
‚Ä¢Large number of users and serversKerberos
‚Ä¢scenario: users at workstations wish to access services on servers 
distributed throughout the network ‚Äìmany to many authenticationKerberos
‚Ä¢a centralized authentication server provides mutual authentication 
between users and servers
‚Ä¢a key distribution and user authentication service developed at MIT
‚Ä¢works in an open distributed environment
‚Ä¢client -service model
‚Ä¢Kerberos protocol messages are protected against eavesdropping and 
replay attacks 
‚Ä¢Kerberos v4 and v5 [RFC 4120]A Simple Authentication Dialogue
‚Ä¢1. C ‚Äî>AS: IDC||PC ||IDV
‚Ä¢2. AS ‚Äî> C : Ticket = E(KV, [IDC||ADC ||IDV])
‚Ä¢3. C ‚Äî> V: IDC|| Ticket
‚Ä¢AS ‚Äìauthentication server 
‚Ä¢ID*-identifier
‚Ä¢PC -password of user
‚Ä¢ADC-network address of C
‚Ä¢KV -secret encryption key shared by AS and V
AS
C
V1
2
3Cheat sheet
‚Ä¢Allow for half of an A4 paperLecture 23Kerberos
‚Ä¢scenario: users at workstations wish to access services on servers 
distributed throughout the network ‚Äìmany to many authenticationKerberos
‚Ä¢a centralized authentication server provides mutual authentication 
between users and servers
‚Ä¢a key distribution and user authentication service developed at MIT
‚Ä¢works in an open distributed environment
‚Ä¢client -service model
‚Ä¢Kerberos protocol messages are protected against eavesdropping and 
replay attacks 
‚Ä¢Kerberos v4 and v5 [RFC 4120]A Simple Authentication Dialogue
‚Ä¢1. C ‚Äî>AS: IDC||PC ||IDV
‚Ä¢2. AS ‚Äî> C : Ticket = E(KV, [IDC||ADC ||IDV])
‚Ä¢3. C ‚Äî> V: IDC|| Ticket
‚Ä¢AS ‚Äìauthentication server 
‚Ä¢ID*-identifier
‚Ä¢PC -password of user
‚Ä¢ADC-network address of C
‚Ä¢KV -secret encryption key shared by AS and V
AS
C
V1
2
3Advantage
‚Ä¢Client and malicious attacker cannot alter IDC(impersonate), 
ADC(change of address), IDV
‚Ä¢server V can verify the user is authenticated through IDC, and grants 
service to C
‚Ä¢guarantee the ticket is valid only if it is transmitted from the same 
client that initially requested the ticket
Secure?
‚Ä¢Insecure : password is transmitted openly and frequently
‚Ä¢Solution: no password transmitted by involving ticket -granting server 
(TGS)
A More Secure Authentication Dialogue
‚Ä¢Once per user logon session
‚Ä¢(1) C ‚Äî>AS:    IDC||IDtgs
‚Ä¢(2) AS ‚Äî> C:   E(KC, Tickettgs)
‚Ä¢Once per type of service:
‚Ä¢(3) C‚Äî>TGS:   IDC||IDv||Tickettgs
‚Ä¢(4) TGS ‚Äî> C:   TicketV
‚Ä¢Once per service session:
‚Ä¢(5) C ‚Äî> V:  IDC|| TicketV
AS
C
V1
2
3, Tickettgs
TGS4
5
TicketVLecture 24Secure?
‚Ä¢Insecure : password is transmitted openly and frequently
‚Ä¢Solution: no password transmitted by involving ticket -granting server 
(TGS)
A More Secure Authentication Dialogue
‚Ä¢Once per user logon session
‚Ä¢(1) C ‚Äî>AS:    IDC||IDtgs
‚Ä¢(2) AS ‚Äî> C:   E(KC, Tickettgs)
‚Ä¢Once per type of service:
‚Ä¢(3) C‚Äî>TGS:   IDC||IDv||Tickettgs
‚Ä¢(4) TGS ‚Äî> C:   TicketV
‚Ä¢Once per service session:
‚Ä¢(5) C ‚Äî> V:  IDC|| TicketV
AS
C
V1
2
3, Tickettgs
TGS4
5
TicketVAdvantage
‚Ä¢No password transmitted in plaintext
‚Ä¢Ticket is reusable. Timestamp is added to prevent reuse of ticket by 
an attackerSecure?
‚Ä¢Ticket hijacking 
‚Ä¢Malicious user may steal the service ticket of another user on the same workstation 
and try to use it 
‚Ä¢Network address verification does not help
‚Ä¢Servers must verify that the user who is presenting the ticket is the same user to 
whom the ticket was issued 
‚Ä¢No server authentication
‚Ä¢Attacker may misconfigure the network so that he receives messages addressed to a 
legitimate server ‚Äìman in the middle attack
‚Ä¢Capture private information from users and/or deny service
‚Ä¢Servers must prove their identity to users
‚Ä¢Solution : section keyno user authentication
Lecture 3Story‚Ä¶
‚Ä¢The bear race
‚Ä¢Takeaway: Even if a defense is not 
perfect, it is important to always 
stay on top of best security 
measures
I don‚Äôt have to outrun the bear. I just have to outrun youDesign in security from the start
‚Ä¢When building a new system, include security as part of the design 
considerations rather than patching it after the fact
‚Ä¢A lot of systems today were not designed with security from the start, 
resulting in patches that don ‚Äôt fully fix the problem!
‚Ä¢Keep these security principles in mind whenever you write code!Human Factors
‚Ä¢The users
‚Ä¢Users like convenience (ease of use)
‚Ä¢If a security system is unusable, it will be unused
‚Ä¢Users will find way to subvert security systems if it makes their lives easier
‚Ä¢The programmers
‚Ä¢Programmers make mistakes
‚Ä¢Programmers use tools that allow them to make mistakes (e.g. C and C++)
‚Ä¢Everyone else
‚Ä¢Social engineering attacks exploit other people ‚Äôs trust and access for personal 
gainSummary for Chapter 1
‚Ä¢Have learned:
‚Ä¢Security requirements
‚Ä¢Attack models
‚Ä¢X.800 secure architecture, security services, mechanismsSupplementary materials
‚Ä¢Internet Security Glossary, v 2 ‚Äìproduced by Internet Society 
https://datatracker.ietf.org/doc/html/rfc 4949
‚Ä¢X.800 ‚ÄìOSI network security
https://www.itu.int/rec/dologin_pub.asp?lang=f&id=T -REC-X.800-
199103 -I!!PDF -E&type=itemsReview Questions
‚Ä¢William Stallings (WS), ‚ÄúNetwork Security 
Essentials ‚Äù, 6thGlobal Edition
‚Ä¢RQ 1.1 -1.3
‚Ä¢Prob 1.5
Network Security
Chapter 2Symmetric encryption
‚Ä¢Sender and recipient share a common/same key
‚Ä¢Was the only type of cryptography, prior to invention of public -key in 
1970‚ÄôsSymmetric Encryption PrinciplesSimplified model of symmetric encryption
Symmetric encryption
‚Ä¢Has five ingredients
‚Ä¢Plaintext :  the original message or data
‚Ä¢Encryption algorithm : performs various substitutions and transformations on 
the plaintext
‚Ä¢Secret key
‚Ä¢Ciphertext : the coded message
‚Ä¢Decryption algorithm : takes the ciphertext and the same secret key and 
produces the original plaintextOther basic terminology
‚Ä¢cipher -algorithm for transforming plaintext to ciphertext 
‚Ä¢encipher (encrypt) -converting plaintext to ciphertext
‚Ä¢decipher (decrypt) -recovering plaintext from ciphertext
‚Ä¢cryptography -study of encryption principles/methods
‚Ä¢cryptanalysis (codebreaking) -the study of principles/ methods of 
deciphering ciphertext without knowing keyRequirements
‚Ä¢Two requirements for secure use of symmetric encryption:
‚Ä¢a strong encryption algorithm
‚Ä¢a secret key known only to sender / receiver
Y = EK(X)
X = DK(Y)
‚Ä¢assume encryption algorithm is known
‚Ä¢the security of symmetric encryption depends on the secrecy of the 
key
‚Ä¢implies a secure channel to distribute keyLecture 4Requirements
‚Ä¢Two requirements for secure use of symmetric encryption:
‚Ä¢a strong encryption algorithm
‚Ä¢a secret key known only to sender / receiver
Y = EK(X)
X = DK(Y)
‚Ä¢assume encryption algorithm is known
‚Ä¢the security of symmetric encryption depends on the secrecy of the 
key
‚Ä¢implies a secure channel to distribute keyA strong encryption algorithm
attacker encryption algorithmplaintext / enquiry
cyphertext / response
Secure Encryption Scheme
‚Ä¢Unconditional security
‚Ä¢no matter how much computer power is available, the cipher cannot be 
broken since the ciphertext provides insufficient information to uniquely 
determine the corresponding plaintext
‚Ä¢Computational security
‚Ä¢the cost of breaking the cipher exceeds the value of the encrypted 
information;
‚Ä¢or the time required to break the cipher exceeds the useful lifetime of the 
informationDesired characteristics
‚Ä¢Cipher needs to completely obscure statistical properties of original 
message
‚Ä¢more practically Shannon suggested combining elements to obtain:
‚Ä¢Confusion ‚Äìhow does changing a bit of the key affect the ciphertext?
‚Ä¢Diffusion ‚Äìhow does changing one bit of the plaintext affect the ciphertext?
confusion
ciphertext
plaintextdiffusion
Ways to achieve
‚Ä¢Symmetric Encryption: 
‚Ä¢substitution / transposition / hybrid
‚Ä¢Asymmetric Encryption: 
‚Ä¢Mathematical hardness -problems that are efficient to compute in one 
direction, but inefficient to reverse by the attacker
‚Ä¢Examples: Modular arithmetic, factoring, discrete logarithm problem, Elliptic Logs over 
Elliptic CurvesProject
‚Ä¢TA Name: Lin, Yu
‚Ä¢Email:  Yu.Lin@ttu.edu
‚Ä¢Form a group (no submission)
‚Ä¢The project will be assigned as a group project. Six students will be 
considered a group for a project. Here is the link to enter your project 
group member names.
FALL 2023 CS5342 PROJECT GROUP NAMES.xlsx
‚Ä¢It is recommended that one person in the group fills in the form to 
avoid multiple entries and submits project files on Blackboard. If you 
cannot get a group, contact the TA.
‚Ä¢Deadline to submit your group members is 11:59 PM on Sept 8th, 2023Lecture 5Review
‚Ä¢Strong Encryption Algorithm
‚Ä¢Confusion
‚Ä¢DiffusionSymmetric Block EncryptionBlock cipher
‚Ä¢the most commonly used symmetric encryption algorithms
‚Ä¢input: fixed -size blocks (Typically 64, 128 bit blocks), output: equal 
size blocks
‚Ä¢provide secrecy and/or authentication services
‚Ä¢Data Encryption Standard (DES), triple DES (3DES), and the Advanced 
Encryption Standard (AES)s
‚Ä¢Usually employ Feistel structure Feistel Cipher StructureFeistel Cipher Structure
‚Ä¢most symmetric block ciphers are based on a Feistel Cipher Structure
‚Ä¢based on the two primitive cryptographic operations
‚Ä¢substitution (S-box)
‚Ä¢permutation (P-box)
‚Ä¢provide confusion and diffusion of message Feistel Cipher Structure
‚Ä¢Horst Feistel devised the feistel cipher in the 1973
‚Ä¢based on concept of invertible product cipher
‚Ä¢partitions input block into two halves
‚Ä¢process through multiple rounds which
‚Ä¢perform a substitution on left data half
‚Ä¢based on round function of right half & subkey
‚Ä¢then have permutation swapping halves
‚Ä¢implements Shannon‚Äôs substitution -permutation network conceptFeistel Encryption and Decryption 
DES encryption
‚Ä¢64 bits plaintext
‚Ä¢56 bits effective key lengthLecture 6Outline
‚Ä¢DES
‚Ä¢3DES
‚Ä¢AESDES encryption
‚Ä¢64 bits plaintext
‚Ä¢56 bits effective key lengthDES Weakness
‚Ä¢short length key (56 bits) is not secure enough. Brutal force search 
takes short time. Triple DES (3DES)
Decrypting with the wrong key will further convolute the output3DES
‚Ä¢Triple DES with three different keys ‚Äìbrute -force complexity 2168
‚Ä¢3DES is the FIPS -approved symmetric encryption algorithm
‚Ä¢Weakness: slow speed for encryption
FIPS ‚ÄìFederal Information Processing Standards. The United States' Federal Information Processing Standards are publicly announced 
standards developed by the National Institute of Standards and Technology for use in computer systems by non -military American government 
agencies and government contractorsAES
‚Ä¢clearly a replacement for DES was needed
‚Ä¢have theoretical attacks that can break it
‚Ä¢have demonstrated exhaustive key search attacks
‚Ä¢can use Triple -DES ‚Äìbut slow with small blocks
‚Ä¢US NIST issued call for ciphers in 1997
‚Ä¢15 candidates accepted in Jun 98 
‚Ä¢5 were short -listed in Aug -99 
‚Ä¢Rijndael was selected as the AES in Oct -2000
‚Ä¢issued as FIPS PUB 197 standard in Nov -2001 Criteria to evaluate AES
‚Ä¢General security
‚Ä¢Software implementations
‚Ä¢Restricted -space environments
‚Ä¢Hardware implementations
‚Ä¢Attacks on implementations
‚Ä¢Encryption versus decryption
‚Ä¢Key agility
‚Ä¢Other versatility and flexibility
‚Ä¢Potential for instruction -level parallelism
Cryptographic Standards and Guidelines | CSRC (nist.gov)AES Specification
‚Ä¢symmetric block cipher 
‚Ä¢128-bit data, 128/192/256 -bit keys 
‚Ä¢stronger & faster than Triple -DES 
‚Ä¢provide full specification & design details 
‚Ä¢both C & Java implementations
‚Ä¢NIST have released all submissions & unclassified analyses
https://csrc.nist.gov/CSRC/media/Projects/Cryptographic -Standards -
and-Guidelines/documents/aes -development/Rijndael -ammended.pdfThe AES Cipher -Rijndael 
‚Ä¢designed by Rijmen -Daemen in Belgium 
‚Ä¢has 128/192/256 bit keys
‚Ä¢an iterative rather than feistel cipher
‚Ä¢treats data in 4 groups of 4 bytes
‚Ä¢operates an entire block in every round
‚Ä¢designed to be:
‚Ä¢resistant against known -plaintext attacks
‚Ä¢speed and code compactness on many CPUs
‚Ä¢design simplicityRijndael
‚Ä¢processes data as 4 groups of 4 bytes (state) = 128 bits
‚Ä¢has 10/12/14 rounds in which state undergoes: 
‚Ä¢byte substitution ( 1 S-box used on every byte) 
‚Ä¢shift rows (permute bytes row by row) 
‚Ä¢mix columns (alter each byte in a column as a function of all of the bytes in 
the column) 
‚Ä¢add round key (XOR state with key material) 
‚Ä¢128-bit keys ‚Äì10 rounds, 192-bit keys ‚Äì12 rounds, 256-bit keys ‚Äì14 
rounds
Project
‚Ä¢Task 1: G1 to G5
‚Ä¢Task 2: G6 to G10
‚Ä¢We will create submission portal on BB. 
‚Ä¢The deadline for the first round of submissions is 10/13/2023 at 11:59 
PM.Lecture 7Outline
‚Ä¢AES
‚Ä¢Random numberRijndael
‚Ä¢processes data as 4 groups of 4 bytes (state) = 128 bits
‚Ä¢has 10/12/14 rounds in which state undergoes: 
‚Ä¢byte substitution (1 S -box used on every byte) 
‚Ä¢shift rows (permute bytes row by row) 
‚Ä¢mix columns (alter each byte in a column as a function of all of the bytes in 
the column) 
‚Ä¢add round key (XOR state with key material) 
‚Ä¢128-bit keys ‚Äì10 rounds, 192 -bit keys ‚Äì12 rounds, 256 -bit keys ‚Äì14 
rounds
AES Encryption and Decryption
AES encryption round
AES pros
‚Ä¢Most operations can be combined into XOR and table lookups -hence 
very fast & efficientTake -home Exercises
‚Ä¢Find an AES code to encrypt a text (A), then decrypt it and check 
whether the original text (A) equals the decrypted text (B). Whether A 
= B?
‚Ä¢Compare the decryption time with different key lengths, and with DES 
and 3DES. 
‚Ä¢Suggestions: find a large A file. Run decryption a couple of times and take the 
average. Reading materials
‚Ä¢FIPS 197, Advanced Encryption Standard (AES) (nist.gov)Lecture 8Random and Pseudorandom NumbersWhen to use random numbers?
‚Ä¢Generation of a stream key for symmetric stream cipher 
‚Ä¢Generation of keys for public -key algorithms
‚Ä¢RSA public -key encryption algorithm (described in Chapter 3)
‚Ä¢Generation of a symmetric key for use as a temporary session key
‚Ä¢used in a number of networking applications, such as Transport Layer Security 
(Chapter 5), Wi -Fi (Chapter 6), e -mail security (Chapter 7), and IP security 
(Chapter 8) 
‚Ä¢In a number of key distribution scenarios
‚Ä¢Kerberos (Chapter 4)Two types of random numbers
‚Ä¢True random numbers:
‚Ä¢generated in non -deterministic ways. They are not predictable and repeatable
‚Ä¢Pseudorandom numbers:
‚Ä¢appear random, but are obtained in a deterministic, repeatable, and 
predictable mannerProperties of Random Numbers
‚Ä¢Randomness
‚Ä¢Uniformity
‚Ä¢distribution of bits in the sequence should be uniform 
‚Ä¢Independence
‚Ä¢no one subsequence in the sequence can be inferred from the others 
‚Ä¢Unpredictable
‚Ä¢satisfies the "next -bit test‚ÄúEntropy
‚Ä¢A measure of uncertainty
‚Ä¢In other words, a measure of how unpredictable the outcomes are
‚Ä¢High entropy = unpredictable outcomes = desirable in cryptography
‚Ä¢The uniform distribution has the highest entropy (every outcome equally 
likely, e.g. fair coin toss)
‚Ä¢Usually measured in bits (so 3 bits of entropy = uniform, random distribution 
over 8 values)
Entropy of an information source
Lecture 9True random numbers generators
‚Ä¢Several sources of randomness ‚Äìnatural sources of randomness
‚Ä¢decay times of radioactive materials
‚Ä¢electrical noise from a resistor or semiconductor
‚Ä¢radio channel or audible noise
‚Ä¢keyboard timings
‚Ä¢disk electrical activity
‚Ä¢mouse movements
‚Ä¢Physical unclonable function (PUF)
‚Ä¢Some are better than others
Combining sources of randomness
‚Ä¢Suppose r1, r2, ‚Ä¶, rkare random numbers from different sources. 
E.g.,
r1 = electrical noise from a resistor or semiconductor
r2 = sample of hip -hop music on radio
r3 = clock on computer
b = r1‚äïr2‚äï‚Ä¶‚äïrk
If any one of r1, r2, ‚Ä¶, rkis truly random, then so is b
Many poor sources + 1 good source = good entropyPseudorandom Number Generators (PRNGs)
‚Ä¢True randomness is expensive
‚Ä¢Pseudorandom number generator (PRNGs ): An algorithm that uses a 
little bit of true randomness to generate a lot of random -looking 
output
‚Ä¢Also called deterministic random bit generators (DRBGs )
‚Ä¢PRNGs are deterministic: Output is generated according to a set 
algorithm
‚Ä¢However, for an attacker who can ‚Äôt see the internal state, the output is 
computationally indistinguishable from true randomnessPRNG: Definition
‚Ä¢A PRNG has two functions:
‚Ä¢PRNG.Seed (randomness): Initializes the internal state using the entropy
‚Ä¢Input: Some truly random bits
‚Ä¢PRNG.Generate (n): Generate npseudorandom bits
‚Ä¢Input: A number n
‚Ä¢Output: npseudorandom bits
‚Ä¢Updates the internal state as needed
‚Ä¢Properties
‚Ä¢Correctness : Deterministic
‚Ä¢Efficiency : Efficient to generate pseudorandom bits
‚Ä¢Security : Indistinguishability from random
‚Ä¢Rollback resistance : cannot deduce anything about any previously -generated 
bit
Example construction of PRNG
‚Ä¢Using block cipher in Counter (CTR) mode:
‚Ä¢If you want m random bits, and a block cipher with Ekhas n bits, apply the 
block cipher m/n times and concatenate the result:
‚Ä¢PRNG.Seed (K | IV) = Ek(IV, 1) | Ek(IV, 2) | Ek(IV, 3) ‚Ä¶ Ek(IV, ceil(m/n)),
‚Ä¢| is concatenation
‚Ä¢Initialization vector (IV) /Nonce ‚Äìtypically is random or pseudorandom
Randomness, 
PRNG outputPRNG: Security
‚Ä¢Can we design a PRNG that is truly random?
‚Ä¢A PRNG cannot be truly random
‚Ä¢The output is deterministic given the initial seed
‚Ä¢A secure PRNG is computationally indistinguishable from random to 
an attacker
‚Ä¢Game: Present an attacker with a truly random sequence and a sequence 
outputted from a secure PRNG
‚Ä¢An attacker should be able to determine which is which with probability ‚âà0
‚Ä¢Equivalence: An attacker cannot predict future output of the PRNGCreate pseudorandom numbers
‚Ä¢Truly random numbers are impossible with any program!
‚Ä¢However, we can generate seemingly random numbers, called 
pseudorandom numbers
‚Ä¢The function rand() returns a non -negative number between 0 and 
RAND_MAX
‚Ä¢For C, it is defined in stdlib.hPRNGs: Summary
‚Ä¢True randomness requires sampling a physical process
‚Ä¢PRNG: An algorithm that uses a little bit of true randomness to 
generate a lot of random -looking output
‚Ä¢Seed(entropy): Initialize internal state
‚Ä¢Generate(n): Generate n bits of pseudorandom output
‚Ä¢Security: computationally indistinguishable from truly random bits